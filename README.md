### 동시성이 발생할 것 같은 상황
1. 유저가 포인트를 충전하는 상황
2. 유저가 포인트를 사용하는 상황

위 2가지 상황에서 동시성이 발생할 수 있다고 생각했습니다.  
이유는, 유저가 포인트를 충전/사용하기 전에 '조회' 후, 충전/사용을 하기 때문입니다.  
이 상황에서 동시에 여러 요청이 들어오면 포인트에 대한 Race Condition이 발생할 수 있다고 판단했습니다.

### 동시성 제어할 수 있는 방법과 어떤 방법을 선택했는지? 그 이유는?
1. Synchronized 키워드 사용
2. DB 단에서 제공하는 Lock 사용 (비관적 락, 낙관적 락)
3. 분산 Lock (Redis)

위 3가지 방법이 제가 알고 있는 방법이고, 저는 1번 Sychronized 키워드를 사용했습니다.
이유는 다음과 같습니다.
- 단순하게, DB 를 사용하고 있지 않으니까 2번은 고려하지 않았습니다.
- 또한 단일 서버 환경으로 판단했기 때문에 3번또한 고려하지 않았습니다.
- 단일 서버에서, DB 를 사용하지 않는 상황이기 때문에 충분히 Synchronized 키워드를 사용해서 제어할 수 있다고 판단했고, `8ba080d` 커밋에서 Synchronized 키워드로 동시성을 제어하고 테스트를 진행했을 때 정상적으로 충전/사용되는 것을 확인했습니다.
- Synchronized 블럭을 사용해서 포인트를 조회하고 충전/사용하는 부분을 묶는 방법도 고려했으나, 메소드 단위로 Synchronized 키워드를 붙이는 것이 더 효율적일 것 같다고 판단해서 메소드 단위로 Synchronized 키워드를 붙였습니다.
  - 해당 부분은 여러 유저가 동시에 접근하는 케이스가 아닌, 특정 유저만 동시에 여러 요청을 보내는 케이스이기 때문에 메소드 단위로 Synchronized 키워드를 붙여도 무방하다고 판단했습니다.
